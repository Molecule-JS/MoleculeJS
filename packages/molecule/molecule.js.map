{"version":3,"file":"molecule.js","sourceRoot":"","sources":["src/molecule.ts"],"names":[],"mappings":"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","sourcesContent":["import { camelCaseToKebab } from './lib/helpers/camel-to-kebab-case.js';\n\nexport { camelCaseToKebab };\n\nexport interface Properties {\n    [propName: string]: PropConfig | Type;\n}\n\nexport type Type = typeof String | typeof Number | typeof Boolean | typeof Array | typeof Object | typeof Date;\n\nexport interface PropConfig {\n    type: Type;\n    reflectToAttribute?: boolean;\n    value?: any;\n    observer?: string;\n    notify?: boolean;\n}\n\nexport interface Data {\n    [propName: string]: any;\n}\n\nexport interface MethodsToCall {\n    [propName: string]: (newValue: any, oldValue: any) => any;\n}\n\nexport interface HTMLCollectionByID {\n    [id: string]: HTMLElement | Element;\n}\n\nexport interface MoleculeEventInit extends EventInit {\n    composed: boolean;\n}\n\n/**\n * \n * @param {string} prop The name of the property to create\n * @param {string} attr The name of the attribute\n * @param {any} context The context of the element\n * @param {PropConfig} info The configuration of the property\n */\nexport function createProperty(prop: string, context: any, info: PropConfig) {\n    // get value that was already set on the property (if any)\n    const setVal = context[prop];\n    Object.defineProperty(context, prop, {\n        get() {\n            return context.__data[prop];\n        },\n        async set(val: any) {\n            const resolved: any = (val != null && val instanceof Promise\n                ? await val\n                : val);\n            context.setProperty(prop, resolved);\n        }\n    });\n\n    if (info.reflectToAttribute &&\n        (info.type === Object || info.type === Array)) {\n        console.warn('Rich Data shouldn\\'t be set as attribte!')\n    }\n    if (info.observer) {\n        if (context[info.observer]) {\n            // Establish the property-change observer\n            context.__methodsToCall[prop] = context[info.observer].bind(context);\n        } else {\n            console.warn(`Method ${info.observer} not defined!`);\n        }\n    }\n    // Check, if the property was already set, set it accordingly\n    if (setVal) {\n        context[prop] = setVal;\n        return;\n    }\n    if (info.value !== undefined) {\n        // Initialize using the included value and the new setter()\n        context[prop] = (typeof (info.value) === 'function'\n            ? info.value.call(context)\n            : info.value);\n\n    }\n}\n\n/**\n * Returns a class with the Molecule features, that extends `superclass`.\n * @param superclass\n */\nexport const Molecule =\n    <T>(superclass = HTMLElement,\n        renderFunction: (result: T, container: Element | DocumentFragment) => void) =>\n        class extends superclass {\n            static properties: Properties;\n            __renderCallbacks: Set<any> = new Set();\n            __pendingRender: boolean = false;\n            __data: Data = {};\n            __methodsToCall: MethodsToCall = {};\n            __wait: any;\n            __firstRender: boolean = false;\n            afterRender?: (isFirst: boolean) => void;\n            shadowRoot!: ShadowRoot;\n            __propAttr: Map<string, string> = new Map(); // propertyName   -> attribute-name\n            __attrProp: Map<string, string> = new Map(); // attribute-name -> propertyName\n            [key: string]: any\n\n            static get observedAttributes(): Array<string> {\n                let attrs: Array<string> = [];\n                for (const prop in this.properties) {\n                    if ((<PropConfig>this.properties[prop]).reflectToAttribute) {\n                        attrs.push(camelCaseToKebab(prop));\n                    }\n                }\n                return attrs;\n            }\n\n            protected constructor() {\n                super();\n                this.attachShadow({ mode: 'open' });\n\n                for (let prop in (this.constructor as any).properties) {\n                    const attr = camelCaseToKebab(prop);\n                    this.__propAttr.set(prop, attr);\n                    this.__attrProp.set(attr, prop);\n                }\n            }\n\n            connectedCallback() {\n                const props = (this.constructor as any).properties;\n                this.__wait = true;\n                for (let prop in props) {\n                    if (typeof props[prop] === 'function')\n                        props[prop] = { type: props[prop] };\n                    this.__makeGetterSetter(prop, props[prop])\n                }\n                delete this.__wait;\n\n                this.__firstRender = true;\n\n                if (this.connected)\n                    this.connected.call(this);\n\n                /* Perform the first render after connection immediately\n                 * without the delay of refresh()\n                 */\n                this.postponedRender();\n            }\n\n            disconnectedCallback() {\n                if (this.disconnected)\n                    this.disconnected.call(this);\n            }\n\n            /**\n             * Creates the Propertyaccessors for the defined properties of the Element.\n             * @param {string} prop\n             * @param {PropConfig} info\n             */\n            __makeGetterSetter(prop: string, info: PropConfig) {\n                createProperty(prop, this, info);\n            }\n\n            /**\n             * Gets called when the properties change and the Element should rerender.\n             *\n             * @param {string} prop\n             * @param {any} newVal\n             */\n            __propertiesChanged(prop: string, newVal: any) {\n                if (this.__data[prop] !== newVal) {\n                    const oldVal = this.__data[prop];\n                    let doRefresh = true;\n                    this.__data[prop] = newVal;\n\n                    if (this.__methodsToCall[prop]) {\n                        if (this.__methodsToCall[prop](newVal, oldVal) === false) {\n                            doRefresh = false;\n                        }\n                    }\n\n                    if (doRefresh) {\n                        this.refresh();\n                    }\n                }\n            }\n            /**\n             * Set the prop to a new value, or signal that it changed\n             * \n             * @param {string} prop \n             * @param {*} [newVal] \n             */\n            setProperty(prop: string, newVal?: any) {\n                if (arguments.length < 2)\n                    newVal = this[prop];\n                const info = (this.constructor as any).properties[prop];\n                const attr = this.__propAttr.get(prop);\n                if (info.reflectToAttribute) {\n                    /* Set the new value by setting the observed attribute.\n                     * This will trigger attributeChangedCallback() which will\n                     * convert the attribute data to a property,\n                     * (this.__data[prop]) and trigger __propertiesChanged().\n                     */\n                    this.setAttribute(attr!, newVal);\n                } else {\n                    /* Set the property directly and trigger\n                     * __propertiesChanged()\n                     */\n                    this.__propertiesChanged(prop, newVal);\n                }\n                if (info.notify) {\n                    this.dispatchEvent(new CustomEvent(`${attr}-changed`, <MoleculeEventInit>{\n                        bubbles: true,\n                        composed: true,\n                        detail: newVal\n                    }));\n                }\n            }\n\n            /**\n             * Gets called when an observed attribute changes. Calls `__propertiesChanged`\n             *\n             * @param {string} prop\n             * @param {any} old\n             * @param {any} val\n             */\n            attributeChangedCallback(attr: string, old: any, val: any) {\n                if (old === val) return;\n                const prop = <string>this.__attrProp.get(attr);\n                if (this.__data[prop] !== val) {\n                    const { type } = (this.constructor as any).properties[prop];\n                    let newVal = val;\n\n                    switch (type.name) {\n                        case 'Boolean':\n                            /* Ensure attribute values the indicate that absense of the\n                             * attribute actually cause the attribute to be absent.\n                             */\n                            if (val === 'false' || val === 'null' ||\n                                val === 'undefined' ||\n                                val === false || val === null) {\n                                this.removeAttribute(attr);\n                                newVal = false;\n                            } else {\n                                newVal = this.hasAttribute(attr);\n                                if (newVal)\n                                    this.setAttribute(attr, '');\n                            }\n                            break;\n\n                        case 'String':\n                            /* If a String value is falsey or the explicit 'null'\n                             * or 'undefined' string, ensure that the attribute is\n                             * removed.\n                             */\n                            if (!val || val === 'null' || val === 'undefined') {\n                                this.removeAttribute(attr);\n                                newVal = '';\n\n                            } else {\n                                newVal = type(val);\n                            }\n                            break;\n\n                        default:\n                            newVal = type(val);\n                            break;\n                    }\n\n                    /* Pass along the new, more concrete *property* value instead of\n                     * the fuzzy attribute value.\n                     */\n                    this.__propertiesChanged(prop, newVal);\n                }\n            }\n\n            /**\n             *  Handle a postponed render.\n             *  @method postponedRender\n             *\n             *  @return void\n             */\n            postponedRender() {\n                renderFunction(this.render({ ...this.__data }), this.shadowRoot)\n\n                for (let callback of this.__renderCallbacks) {\n                    callback();\n                }\n                this.__renderCallbacks.clear();\n\n                if (this.afterRender) {\n                    this.afterRender(this._firstRender);\n                    this._firstRender = false;\n                }\n            }\n\n            /**\n             *  Refresh this element, re-rendering.\n             *  @method refresh\n             *  @param {function} callback\n             *\n             *  @return void\n             */\n            async refresh(callback?: () => any) {\n                if (this._wait === true) { return }\n\n                if (callback != null) {\n                    // Queue this render/refresh callback\n                    this.__renderCallbacks.add(callback);\n                }\n\n                if (!this.__pendingRender) {\n                    this.__pendingRender = true;\n                    /* Schedule the following as a microtask, which runs before\n                     * requestAnimationFrame. Any additional refresh() calls\n                     * will have any callback queued but otherwise will be\n                     * ignored.\n                     *\n                     * https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\n                     */\n                    this.__pendingRender = await false;\n                    this.postponedRender();\n                }\n            }\n\n            /**\n             * Returns should be passed to the render function.\n             *\n             * @returns\n             */\n            render(data?: object): T {\n                throw Error('render function not defined');\n            }\n\n            /**\n             * Gets all children with ids.\n             *\n             * @readonly\n             */\n            get $(): HTMLCollectionByID {\n                const arr = this.shadowRoot.querySelectorAll('[id]');\n                const obj: HTMLCollectionByID = {};\n                for (const el of arr) {\n                    obj[el.id] = el;\n                }\n\n                return obj;\n            }\n        }\n"]}